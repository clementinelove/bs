#lang racket
(require "lexer.rkt"
         scribble/srcdoc)

(define FOUR-BYTE-INT-BOUND (/ (expt 256 4) 2)) ;; no op input should take a decimal of total 4 byte

(define (display-stack stk)
  (letrec ([helper
            (lambda (s)
              (if (stack-empty? s)
                  (displayln "---BOT---")
                  (begin
                    (printf "~s\n" (top s))
                    (helper (pop s)))))])
    (displayln "---TOP---")
    (helper stk)))

(define (test-ptrn str)
  (for/fold (;; the main stack
             [stk (empty-stack)]
             ;; the alt stack
             [alt-stk (empty-stack)]
             ;; used after reading an OP_PUSHDATAn command
             [data-size-upper-bound-specifier 0]
             ;; used after reading a data-size specifier
             [required-data-bytes 0]
             ;; transaction state : #f -> needs to break loop and report invalid
             [tran-state #t]
             ;; level is a stack storing level branching information
             ;; each element is a skipping boolean
             ;; #t -> skip current token
             ;; #f -> do not skip
             ;; length of the level decides the block level
             [level '()]
             #:result (cond [(not (null? level))
                             (display "Invalid: Unbalanced OP_IF exist")]
                            [(not tran-state)
                             (display "Invalid: this transaction was being marked as invalid")]
                            [(empty? stk)
                             (display "Invalid: stack is empty after executing script")]
                            [else
                             (let ([top-item (top stk)])
                               (display-stack stk)
                               (if (and (integer? top-item) (= (top stk) 0))
                                   (display "Invalid: top stack item is 0 executing script")
                                   (display "OK: top stack item is a non-zero value")))])
             ;; TODO: just for test: show the current state of the stack
             )
            ;; TODO: let lexer check upper case of opcodes
            ([data (in-list (test-lex str))])
    #:break (not tran-state)
    #;(displayln level) ; DEBUG: show current level
    (if (or (null? level)
            (not (car level)))
        ;; when level is empty, execute any command since it's not in an OP_IF block
        ;; when it's not empty, check (car level): if it's #f then do execute
        (cond
          [(> required-data-bytes 0) ;; true -> start reading data
           ;; if starts reading data,
           ;; it only support reading data types (no opcodes allowed)
           (match data
             [(list 'OP_CODE code)
              (raise-syntax-error #f
                                  "Cannot use opcodes after OP_PUSHDATA")]
             [(list 'HEX bytes)
              (let ([size-of-data-in-bytes (bytes-length bytes)])
                (if (= size-of-data-in-bytes required-data-bytes)
                    (values (push stk bytes) alt-stk
                            0 0
                            tran-state level)
                    (error (if (> size-of-data-in-bytes data-size-upper-bound-specifier)
                               "Cannot express size larger than ~s bytes"
                               "size is smaller than ~s bytes")
                           required-data-bytes)))]
             [(list 'DEC integer)
              ;; TODO: consider show this (and other) syntax error in the parser rather than this func
              ;;       which requires rewrite some of the grammar rules
              (raise-syntax-error #f "Pushdata data must start with 0x")]
             [else
              (error "Failed to parse data ~s" data)])]


          [(> data-size-upper-bound-specifier 0) ;; true -> start reading data size specifier
           ;; TODO: data size specifier can be expressed using either hexadecimal or decimal
           (let ([maximum-data-size (- (expt 256 data-size-upper-bound-specifier) 1)])
             (match data
               [(list 'OP_CODE code)
                (raise-syntax-error #f
                                    "Cannot use opcodes after OP_PUSHDATA"
                                    #'data
                                    #'data)]
               [(list 'HEX bytes) ;; TODO: Does hexadecimal interpreted as an integer?
                (let ([specified-bytes-size (bytes-length bytes)])
                  (if (= specified-bytes-size data-size-upper-bound-specifier)
                      (let ([specified-data-size (bytes->integer bytes)])
                        (if (and (<= 0 specified-data-size)
                                 (<= specified-data-size maximum-data-size))
                            (values stk alt-stk
                                    0 specified-data-size
                                    tran-state level)
                            (error "Size out of specified range"))) ;; TODO: Better error report
                      ;; TODO: consider may not need an error report
                      (error (if (> specified-bytes-size data-size-upper-bound-specifier)
                                 "Cannot specify size larger than ~s bytes"
                                 "Specified size is smaller than ~s bytes")
                             data-size-upper-bound-specifier)))]
               [(list 'DEC integer)
                (if (and (<= 0 integer) (<= integer maximum-data-size))
                    (values stk alt-stk
                            0 integer
                            tran-state level)
                    (error "Size out of range"))] ;; TODO: Better error report
               [else
                (error "Invalid Script: unknwon data" data)]))]


          [(= data-size-upper-bound-specifier 0) ; true -> reading op codes / pushdata (abbr. syntax)
           (match data
             [(list 'OP_CODE code)
              (displayln code) ;; DEBUG: show op code name
              (let ([data-bytes-tobe-pushed (special-op? code)])
                (if (false? data-bytes-tobe-pushed)
                    ;; not an OP_PUSHDATAn command
                    (let-values ([(new-stk new-alt-stk new-tran-state new-level)
                                  ((eval code) stk alt-stk tran-state level)])
                      (values new-stk new-alt-stk
                              0 0
                              new-tran-state new-level))
                    ;; OP_PUSHDATAn : push data onto stack
                    (values stk alt-stk
                            data-bytes-tobe-pushed 0
                            tran-state level)))]
             ;; TODO:
             ;; add support for abbr. syntax version of pushdata (e.g. 4 0x01020304)
             [(list 'HEX data)
              (values stk alt-stk
                      0 (bytes->integer data)
                      tran-state level)]
             [(list 'DEC data) ;; read as the start of pushdata
              (values stk alt-stk
                      0 data
                      tran-state level)]
             [_ (error "Invalid Script: only allows data entry after OP_PUSHDATA instructions"
                       data)])])

        ;; when level stack is not emtpy and (top level) => #t
        ;; which means skip current command until OP_ELSE or OP_ENDIF
        (match data
          [(list 'OP_CODE code)
           (displayln code)
           (if (skipping-executable? code)
               (let-values ([(new-stk new-alt-stk new-tran-state new-level)
                             ((eval code) stk alt-stk tran-state level)])
                 (values new-stk new-alt-stk
                         0 0
                         new-tran-state new-level))
               (values stk alt-stk
                       data-size-upper-bound-specifier required-data-bytes
                       tran-state level))]))))

; TODO:
; "If any input value for any of these commands is longer than 4 bytes,
; the script must abort and fail.
; If any opcode marked as disabled is present in a script -
; it must also abort and fail."

;; OP_CODES type should be: (-> Stack Stack)
(define-for-syntax opcodes (make-hash))

(define-syntax (define-op stx)
  (syntax-case stx (hash-set! opcodes)
    [(define-op (id arg ...) body)
     (begin
       #;(displayln (identifier? #'id))
       (hash-set! opcodes (syntax-e #'id) #'id)
       #'(define (id arg ...) body))]))

(define (op-proc-symbol? v)
  (if (symbol? v)
      (raise-syntax-error #f "not a valid opcode." v #'v)
      (string-prefix? (symbol->string v) "OP_")))

;------------------------
; OPCODES
;------------------------

;; load other opcodes
(require "bitcoin-script/opcodes.rkt")